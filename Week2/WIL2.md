# HTTP

**HyperText Transfer Protocol** : 서로 다른 시스템들 사이에서 통신을 주고받게 해주는 application 계층의 프로토콜

## 특징

1. Transfer layer

    TCP (네트워크 계층의 Network Layer에서 사용하는 프로토콜)/IP 기반으로 서버와 클라이언트 간의 요청과 응답을 전송

2. 비 연결성 (connectionless)

    클라이언트와 서버가 한번 연결을 맺은 후에 클라이언트의 요청에 대해 서버가 응답을 마치면 연결을 끊음

3. 무상태성 (stateless)

    비 연결성으로 인해 서버가 두 요청 간의 어떠한 데이터도 유지하지 않음

    즉, 서버는 클라이언트와 연결에 대한 정보를 저장하지 않아서 클라이언트를 식별하지 못함

## 연결 과정

1. 새 연결 혹은 기존 연결을 재사용하여 TCP 연결 (요청을 보내거나 받는데 사용)을 엶

2. HTTP 메시지 전송

3. 서버가 보낸 응답을 읽음

4. 연결을 닫거나 다른 요청을 위해 재사용

## HTTP 메시지

* HTTP는 HTTP 메시지를 통해 데이터를 주고받음

* HTTP 메시지에는 request (요청)과 respoonse (응답)이 있음

* HTTP 메서드, 경로, HTTP 버전, 헤더로 이루어져 있음

## HTTP 메서드

클라이언트가 서버에 특정 요청을 보낼 때, 웹서버에게 요청하는 목적 및 그 종류를 알리는 수단으로 주로 GET, POST, PUT, PATCH, DELETE를 사용

### 종류

1. GET : 리소스 조회

2. POST : 요청 데이터 처리, 주로 등록에 사용

3. PUT : 리소스를 대체, 해당 리소스가 없으면 생성

4. PATCH : 리소스 부분 변경

5. DELETE : 리소스 삭제

6. HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환

7. OPTIONS : 주로 CORS에서 사용하며 대상 리소스에 대한 통신 가능 옵션 (메서드)을 설명

8. CONNECT : 대상 리소스로 식별되는 서버에 대한 터널을 설정

9. TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

## HTTP 상태 코드

서버 측에서 클라이언트로 요청에 대한 응답을 보낼 때, 해당 요청에 관한 처리 상태를 알려주는 기능으로 응답 상태 코드를 통해 성공/실패 여부를 확인할 수 있음

### 종류

#### 자주 사용하는 HTTP 상태 코드

1. 200 : 클라이언트의 요청을 정상적으로 수행함

2. 201 : POST를 통한 리소스 생성 작업 시 클라이언트가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨

3. 204 : 클라이언트가 어떠한 리소스 삭제를 요청, 해당 리소스가 성공적으로 삭제됨

4. 400 : 클라이언트의 요청이 부적절할 경우 사용하는 응답 코드

5. 401 : 클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답 코드

6. 403 : 유저 인증 상태와 관계없이 응답하고 싶지 않은 리소스를 클라이언트가 요청했을 때 사용하는 응답 코드

7. 404 : 클라이언트가 요청한 리소스에서는 사용 불가능한 메서드를 이용했을 경우 사용하는 응답 코드

8. 500 : 서버에 문제가 있을 경우 사용하는 응답 코드

9. 502 : 게이트웨이 오류

#### 그 외

1. 1xx (Informational) : 요청이 수신되어 처리 중

2. 2xx (Successful) : 요청 정상 처리

3. 3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요

4. 4xx (Client Error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음

5. 5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함

# HTTPS

**Hypertext Transfer Protocol Secure** : HTTP에 데이터 암호화가 추가된 프로토콜

## HTTP vs HTTPS

### HTTP

1. 80번 포트를 사용

2. 암호화가 추가되지 않았기 때문에 보안에 취약

### HTTPS

1. 443번 포트를 사용

2. 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원

# RESTful한 URI 설계

**REST (Respresentational State Transfer)** : Roy Fielding이 소개한 웹의 장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처로 **자원**을 이름으로 구분하여 해당 자원의 **상태**를 **주고, 받는** 모든 것

## 구성 요소

1. 자원

    서버에 있는 것으로 DB 안에 들어가 있는 데이터 (유저, 주문) 또는, 이미지 하나하나를 의미하며 URI를 통해 자원을 명시하고, 구분할 수 있음

2. 조작

    클라이언트는 HTTP 메서드 (POST, GET, DELETE, PUT)를 이용하여 지정한 자원에 대한 조작을 요청

3. 표현

    클라이언트가 서버에게, **자원에 대한 조작을 요청**하면 서버는 이에 대한 적절한 응답 (Representation)을 보냄

## 원칙

1. 인터페이스 일관성 (Uniform Interface)

    HTTP 표준만 따른다면 안드로이드 플랫폼, IOS 플랫폼 등 특정 언어나 플랫폼에 종속되지 않고 사용이 가능한 인터페이스 스타일

2. 무상태성 (Stateless)

    서버는 HTTP 세션과 같은 컨텍스트 저장소에 상태 정보를 저장 안 하고 단순히 요청이 오면 응답을 보내는 역할만 수행하며, 세션 관리는 클라이언트에게 책임이 있음

3. Resource 지향 아키텍처 (ROA : Resource Oriented Architecture)

    Resource 기반의 복수형 명사 형태의 정의를 권장

4. 클라이언트-서버 아키텍처 (Client-Server Architecture)

5. 캐시 기능 (Cacheable)

    HTTP 프로토콜에서 사용하는 태그들을 활용하여 캐싱 처리를 할 수 있음

6. 계층화 (Layered System)

    REST 서버는 다중 계층으로 구성될 수 있으며, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 프록시, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있음

7. 자체 표현 구조 (Self-descriptiveness)

    REST API 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어 있음

## 디자인 가이드

1. URI의 리소스명은 소문자를 사용하고, 동사보다는 명사를 사용

2. 자원에 대한 행위는 HTTP 메서드를 통해서 표현

3. 하이픈 (-)은 URI의 가독성을 위해서 사용, 밑줄 (_)은 사용하지 않음

4. 슬래시 구분자 (/)는 계층 관계를 나타낼 때 사용, URI의 마지막 문자로 사용하면 안 됨

5. 파일 확장자는 URI에 포함시키지 않음

## 과제

* 이벤트 목록 조회

    GET /events

* 이벤트 조회

    GET /events/{eventId}

* 이벤트 등록

    POST /events

* 이벤트 수정

    PATCH /events/{eventId}

* 이벤트 삭제

    DELETE /events/{eventId}

* 이벤트 상태 변경

    PATCH /events/{eventId}/status

* 특정 이벤트의 주문 목록 조회

    GET /events/{eventId}/orders

* 멤버 목록 조회

    GET /members

* 특정 멤버 권한 변경

    PATCH /members/{memberId}/permission

* 특정 멤버 정보 조회

    GET /members/{memberId}/information

* 특정 멤버 정보 변경

    PATCH /members/{memberId}/information

* 멤버 등록

    POST /members