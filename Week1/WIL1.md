# 자바

## 특징

1. 운영체제에 독립적

    * WORA (Write Once, Run Anywhere) : 자바로 작성된 프로그램은 운영체제와 하드웨어에 관계없이 실행 가능

    * JVM (Java Virtual Machine : 자바 애플리케이션을 실행하는 데 사용되는 가상 머신) 이용

2. 객체지향언어

    * 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어

    * 재사용성과 유지보수의 용이성

3. 자동 메모리 관리 (Garbage Collection)

4. 네트워크와 분산처리를 지원

5. 멀티쓰레드를 지원

6. 동적 로딩을 지원

## 문법

### 인터페이스

interface, implements 사용

```java
public interface Calculator {
    int plus(int a, int b);
    int minus(int a, int b);
    int mul(int a, int b);
    int div(int a, int b);
}

public class ALU implements Calculator {
    public int plus(int a, int b) { return a + b; }

    public int minus(int a, int b) { return a - b; }

    public int mul(int a, int b) { return a * b; }

    public int div(int a, int b) { return a / b; }
}
```

### 추상 클래스

abstract, extends 사용

```java
public abstract class Animal {
    public abstract void speak();
}

public class Cat extends Animal {
    @Override
    public void speak() {
        System.out.println("cat says Meow!");
    }
}
```

# 객체지향 프로그래밍

프로그래밍에서 필요한 데이터를 추상화 시켜 **상태와 행위를 가진 객체**로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법

## 장단점

### 장점

1. 코드의 재사용성이 높음

    * 누군가가 만든 클래스를 가져와 사용할 수 있고 상속을 통해 확장할 수도 있음

2. 유지보수가 쉬움

    * 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메소드로 존재하기 때문에 해당 부분만 수정하면 됨

3. 대형 프로젝트에 적합

    * 클래스 단위로 모듈화시켜서 개발할 수 있으므로 업무 분담하기가 쉬움

### 단점

1. 처리 속도가 상대적으로 느림

2. 객체가 많으면 용량이 커질 수 있음

3. 설계 시 많은 노력과 시간이 필요

## 특징

### 1. 추상화

* 객체에서 공통된 속성과 행위를 추출 하는 것

* 공통의 속성과 행위를 찾아서 타입을 정의하는 과정

* 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것

### 2. 캡슐화

* 데이터 구조 (변수)와 데이터를 다루는 방법 (함수)들을 결합 시켜 묶는 것

* **낮은 결합도를 유지**할 수 있도록 설계하는 것

* 속성과 기능을 정의하는 변수와 메소드를 클래스라는 캡슐에 넣어서 분류하는 것으로 **재사용**이 원활하다는 장점이 있고 캡슐화를 통해서 **정보은닉**을 활용 할 수도 있음 (접근제어자의 활용)

### 3. 상속

* 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것

* 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능

#### 장단점

##### 장점

1. 재사용으로 인한 코드가 줄어듬

2. 범용적인 사용이 가능

3. 자료와 메서드의 자유로운 사용 및 추가가 가능

###### 단점

1. 상위 클래스의 변경이 어려워짐

2. 불필요한 클래스가 증가할 수 있음

3. 상속이 잘못 사용될 수 있음

### 4. 다형성

* 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것

* 어떠한 요소에 여러 개념을 넣어 놓는 것

#### 오버라이딩

상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것

#### 오버로딩

같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것

## 설계 원칙

### 1. 단일 책임 원칙 (SRP, Single Responsibility Principle)

* 하나의 클래스는 단 하나의 책임만 가져야 함

* 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있음

### 2. 개방-폐쇄 원칙 (OCP, Open/Closed Principle)

* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함

* 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않음

### 3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

* 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함

* 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함

* 서브 클래스가 확장에 대한 인터페이스를 준수해야 함

### 4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)

* 범용 인터페이스 하나보다 클라이언트를 위한 여러 개의 인터페이스로 구성하는 것이 좋음

* 인터페이스는 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 함

* 클라이언트가 필요로 하는 인터페이스로 분리함으로써 각 클라이언트가 사용하지 않는 인터페이스에 변경이 있어도 영향을 받지 않도록 만들어야 함

* 인터페이스의 단일 책임

### 5. 의존관계 역전 원칙 (DIP, Dependency Inversion Principle)

* 추상화에 의존해야지 구체화에 의존하면 안됨

* 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되고 저수준 모듈은 고수준 모듈에서 정의한 추상 타입에 의존해야 함